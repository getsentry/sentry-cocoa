name: Benchmarking
on:
  push:
    branches:
      - main

  pull_request:
    paths:
      # test changes to Sentry SDK sources
      - "Sources/**"

      # test changes to benchmarking implementation
      - "Samples/iOS-Swift/**"
      - ".github/workflows/benchmarking.yml"
      - ".sauce/benchmarking-config.yml"
      - "fastlane/**"
      - "scripts/ci-select-xcode.sh"
      - "Samples/iOS-Swift/iOS-Swift.yml"
      - "Samples/iOS-Swift/iOS-Swift.xcconfig"
      - "Samples/iOS-Swift/iOS-SwiftClip.xcconfig"
      - "Samples/iOS-Swift/iOS-Benchmarking.xcconfig"
      - "scripts/build-xcframework-slice.sh"
      - "scripts/assemble-xcframework.sh"
      - ".github/workflows/build-xcframework-variant-slices.yml"
      - ".github/workflows/assemble-xcframework-variant.yml"

# Concurrency configuration:
# - We use workflow-specific concurrency groups to prevent multiple benchmark runs on the same code,
#   as benchmarks are extremely resource-intensive and require dedicated device time on SauceLabs.
# - For pull requests, we cancel in-progress runs when new commits are pushed to avoid wasting
#   expensive external testing resources and provide timely performance feedback.
# - For main branch pushes, we never cancel benchmarks to ensure we have complete performance
#   baselines for every main branch commit, which are critical for performance regression detection.
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

jobs:
  build-benchmark-test-target:
    name: Build App and Test Runner
    runs-on: macos-14
    steps:
      - uses: actions/checkout@v4
      - run: ./scripts/ci-select-xcode.sh 15.4
      - uses: ruby/setup-ruby@v1
        with:
          bundler-cache: true
      - name: Install old xcodegen
        # Install xcodegen 2.43.0 for since newer versions don't work with Xcode older than Xcode 16
        run: |
          brew install --formula ./scripts/xcodegen.rb
          brew pin xcodegen
      - run: make init-ci-build
      - run: make xcode-ci
      - name: Install SentryCli
        run: brew install getsentry/tools/sentry-cli
      - name: Cache iOS-Swift App and dSYM build products
        id: ios-swift-cache
        uses: actions/cache@v4
        with:
          path: |
            DerivedData/Build/Products/Debug-iphoneos/iOS-Swift.app.dSYM
            DerivedData/Build/Products/Debug-iphoneos/iOS-Swift.app
          key: ios-swift-for-ui-testing-cache-key-${{ hashFiles('Samples/iOS-Swift/**') }}-${{ hashFiles('Sources/Sentry/**') }}
      - name: Cache iOS-Swift UI Test Runner App build product
        id: ios-swift-benchmark-runner-cache
        uses: actions/cache@v4
        with:
          path: |
            DerivedData/Build/Products/Debug-iphoneos/iOS-Benchmarking-Runner.app
          key: ios-swift-for-ui-testing-cache-key-${{ hashFiles('Samples/iOS-Benchmarking/**') }}
      - run: bundle exec fastlane build_ios_swift_for_tests
        env:
          APP_STORE_CONNECT_KEY_ID: ${{ secrets.APP_STORE_CONNECT_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
          APP_STORE_CONNECT_KEY: ${{ secrets.APP_STORE_CONNECT_KEY }}
          FASTLANE_KEYCHAIN_PASSWORD: ${{ secrets.FASTLANE_KEYCHAIN_PASSWORD }}
          MATCH_GIT_PRIVATE_KEY: ${{ secrets.MATCH_GIT_PRIVATE_KEY }}
          MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}
          MATCH_USERNAME: ${{ secrets.MATCH_USERNAME }}
      - run: bundle exec fastlane build_ios_benchmark_test
        env:
          APP_STORE_CONNECT_KEY_ID: ${{ secrets.APP_STORE_CONNECT_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
          APP_STORE_CONNECT_KEY: ${{ secrets.APP_STORE_CONNECT_KEY }}
          FASTLANE_KEYCHAIN_PASSWORD: ${{ secrets.FASTLANE_KEYCHAIN_PASSWORD }}
          MATCH_GIT_PRIVATE_KEY: ${{ secrets.MATCH_GIT_PRIVATE_KEY }}
          MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}
          MATCH_USERNAME: ${{ secrets.MATCH_USERNAME }}
      - name: Upload dSYMs
        run: |
          sentry-cli --auth-token ${{ secrets.SENTRY_AUTH_TOKEN }} upload-dif --org sentry-sdks --project sentry-cocoa DerivedData/Build/Products/Debug-iphoneos/iOS-Swift.app.dSYM
      - name: Archiving DerivedData
        uses: actions/upload-artifact@v4
        with:
          name: DerivedData-Xcode
          path: |
            **/Debug-iphoneos/iOS-Swift.app
            **/Debug-iphoneos/iOS-Benchmarking-Runner.app

  run-ui-tests-with-sauce:
    name: Run Benchmarks ${{matrix.suite}}
    runs-on: ubuntu-latest
    needs: build-benchmark-test-target
    strategy:
      fail-fast: false
      matrix:
        suite: ["High-end device", "Mid-range device", "Low-end device"]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/download-artifact@v4
        with:
          name: DerivedData-Xcode
      - run: npm install -g saucectl@0.186.0
      - name: Run Benchmarks in SauceLab
        id: run-benchmarks-in-sauce-lab
        env:
          SAUCE_USERNAME: ${{ secrets.SAUCE_USERNAME }}
          SAUCE_ACCESS_KEY: ${{ secrets.SAUCE_ACCESS_KEY }}
        # Note: We are not setting continue-on-error here, because we want the step to be marked as failed.
        run: |
          set -o pipefail && saucectl run \
            --select-suite "${{matrix.suite}}" \
            --config .sauce/benchmarking-config.yml \
            --tags benchmark \
            --verbose \
            2>&1 | tee output.log

      - name: Recovery - Extract Test ID from output
        id: should-retry-test
        # Note: We need to use always() here, because the previous run step might be marked as failed.
        if: ${{ always() && steps.run-benchmarks-in-sauce-lab.outcome == 'failure' }}
        uses: actions/github-script@v7
        env:
          SAUCE_USERNAME: ${{ secrets.SAUCE_USERNAME }}
          SAUCE_ACCESS_KEY: ${{ secrets.SAUCE_ACCESS_KEY }}
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');

            console.log("Extracting test ID from output log");
            const outputLog = fs.readFileSync('output.log', 'utf8');

            // Lookup for the test ID in the output log
            // Note: The CLI output might change over time, so this might need to be updated.
            const match = outputLog.match(/https:\/\/app\.saucelabs\.com\/tests\/([^\s]+)/);
            const testId = match?.[1] ?? '';

            if (!testId) {
              core.warning("No SauceLabs test ID found in CLI output, it might have changed, retrying...");
              core.setOutput('RETRY_TEST', 'true');

              return;
            }

            try {
              console.log(`Checking if the test exists in SauceLabs: ${testId}`);
              execSync(`saucectl jobs get ${testId}`, {
                env: process.env,
                stdio: 'inherit'
              });

              console.log("Test exists but failed, not retrying.");
              core.setFailed('Test exists but failed');
            } catch (error) {
              console.log("Failed to get job, retrying...");
              core.setOutput('RETRY_TEST', 'true');
            }

      - name: Run Benchmarks in SauceLab - Retry 1
        id: run-benchmarks-in-sauce-lab-retry-1
        # Note: We need to use always() here, because the previous run step might be marked as failed.
        if: ${{ always() && steps.should-retry-test.outputs.RETRY_TEST == 'true' }}
        env:
          SAUCE_USERNAME: ${{ secrets.SAUCE_USERNAME }}
          SAUCE_ACCESS_KEY: ${{ secrets.SAUCE_ACCESS_KEY }}
        run: |
          echo "::warning SauceLabs benchmark tests need to be retried"
          set -o pipefail && saucectl run \
            --select-suite "${{matrix.suite}}" \
            --config .sauce/benchmarking-config.yml \
            --tags benchmark \
            --verbose \
            2>&1 | tee retry-output.log

      - name: Force Cancel SauceLabs Job on Workflow Cancellation
        if: ${{ cancelled() }}
        uses: actions/github-script@v7
        env:
          SAUCE_USERNAME: ${{ secrets.SAUCE_USERNAME }}
          SAUCE_ACCESS_KEY: ${{ secrets.SAUCE_ACCESS_KEY }}
        with:
          script: |
            const fs = require('fs');

            console.log("::warning Workflow was cancelled, attempting to cancel SauceLabs jobs");

            // SauceLabs API configuration
            const sauceUsername = process.env.SAUCE_USERNAME;
            const sauceAccessKey = process.env.SAUCE_ACCESS_KEY;
            const apiBaseUrl = 'https://api.us-west-1.saucelabs.com';

            if (!sauceUsername || !sauceAccessKey) {
              console.log("::error SauceLabs credentials not found, cannot cancel jobs");
              return;
            }

            // Function to extract job IDs from log files
            const extractJobIdsFromLog = (logFile) => {
              if (!fs.existsSync(logFile)) {
                console.log(`Log file ${logFile} not found, skipping...`);
                return [];
              }

              console.log(`Checking ${logFile} for SauceLabs test IDs...`);
              const logContent = fs.readFileSync(logFile, 'utf8');

              // Extract all SauceLabs test URLs and get job IDs
              const urlRegex = /https:\/\/app\.saucelabs\.com\/tests\/([^\s]+)/g;
              const jobIds = [];
              let match;

              while ((match = urlRegex.exec(logContent)) !== null) {
                const jobId = match[1];
                if (jobId) {
                  jobIds.push(jobId);
                  console.log(`Found SauceLabs job ID: ${jobId}`);
                }
              }

              return jobIds;
            };

            // Function to cancel a SauceLabs job via REST API
            // Reference: https://docs.saucelabs.com/dev/api/jobs/#stop-a-job
            const cancelSauceLabsJob = async (jobId) => {
              try {
                console.log(`Attempting to cancel SauceLabs job: ${jobId}`);

                // Create basic auth header
                const auth = Buffer.from(`${sauceUsername}:${sauceAccessKey}`).toString('base64');

                // Make PUT request to stop the job
                const response = await fetch(`${apiBaseUrl}/rest/v1/${sauceUsername}/jobs/${jobId}/stop`, {
                  method: 'PUT',
                  headers: {
                    'Authorization': `Basic ${auth}`,
                    'Content-Type': 'application/json'
                  }
                });

                if (response.ok) {
                  console.log(`Successfully cancelled SauceLabs job: ${jobId}`);
                } else if (response.status === 404) {
                  console.log(`Job ${jobId} not found (may already be finished)`);
                } else {
                  const errorText = await response.text();
                  console.log(`Failed to cancel job ${jobId}: HTTP ${response.status} - ${errorText}`);
                }
              } catch (error) {
                console.log(`Error cancelling job ${jobId}: ${error.message}`);
              }
            };

            // Extract job IDs from both possible log files
            const jobIds = [
              ...extractJobIdsFromLog('output.log'),
              ...extractJobIdsFromLog('retry-output.log')
            ];

            // Remove duplicates
            const uniqueJobIds = [...new Set(jobIds)];

            if (uniqueJobIds.length === 0) {
              console.log("No SauceLabs job IDs found in log files");
              return;
            }

            // Cancel all found jobs
            console.log(`Found ${uniqueJobIds.length} unique job(s) to cancel`);
            for (const jobId of uniqueJobIds) {
              await cancelSauceLabsJob(jobId);
            }

            console.log("SauceLabs job cancellation attempts completed");
