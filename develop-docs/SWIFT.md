# Swift Usage

Starting from version 8.0.0, it is now possible to include Swift code in the project. All Swift files should be placed under the `/Sources/Swift` directory.

> In this document, `SentryPrivate` refers to the library written in Swift, while `Sentry` represents the framework written in Objective-C. The term `SentryPrivate` public API refers to the API that will be consumed by `Sentry` and is not intended for direct use by users.

## Notes

1. All Swift code will be bundled within the `SentryPrivate` library, which `Sentry` depends on.
2. User-facing APIs cannot be written in Swift because their components will be accessed through imports from "SentryPrivate."
3. `SentryPrivate` does not have access to `Sentry` classes to avoid cyclic references. As a result, any code written in Objective-C is not accessible from the Swift layer.
   - However, it is possible to create Dependency Injection (DI) APIs in Swift, allowing `Sentry` to inject its objects for use within `SentryPrivate`.
4. `SentryPrivate` public APIs (code consumed by `Sentry`) cannot utilize certain Objective-C incompatible features, including:
   - Generics
   - Non-@objc protocols and protocol extensions
   - Top-level functions and properties
   - Global variables
   - Structs
   - Swift-only enums
   - Swift-only optionals
   - Swift-only tuples

## Objective-C Interoperability

- **ObjC to Swift**: Import `#import "SentrySwift.h"`
- **Swift to ObjC**: Add header to `SentryInternal.h`, then `@_implementationOnly import _SentryPrivate`
- **Module system**: `_SentryPrivate` module for internal ObjC headers accessible to Swift

When making an Objective-C class public for Swift SDK code, do the following:

- Add it to SentryPrivate.h
- Remove existing imports from any test bridging headers.
- Add the import `@_implementationOnly import _SentryPrivate` to your Swift class that wants to use
  the Objective-C class.

To make internal Swift code accessible to ObjC it needs to be `public`. This allows the ObjC header to be generated by Swift Package Manager.
To discourage use outside of the SDK, add `@_spi(Private)` to these declarations. This ensures they can only be used when the import also
adds the SPI attribute.

Public Objective-C classes, made public
[through the umbrella header](https://developer.apple.com/documentation/swift/importing-objective-c-into-swift#Import-Code-Within-a-Framework-Target),
are automatically visible to Swift without imports. Our umbrella header is defined in the `Sentry.modulemap`.
Accessing private Objective-C classes doesn't
work out of the box. One approach to making this work is to define a private module that contains
all the private ObjC headers. To define such a module, we added a module.modulemap file to our
project with the name _SentryPrivate. We added the prefix `_`because Xcode autocomplete seems to ignore such modules. This modulemap file points to a header called`SentryPrivate.h`, which include all private ObjC headers that should be available for Swift. When importing the generated _SentryPrivate module we have to use `@\_implementationOnly import \_SentryPrivate`.
[@_implementationOnly](https://github.com/apple/swift/blob/main/docs/ReferenceGuides/UnderscoredAttributes.md#_implementationonly) will most likely be superseded byÂ [access level imports](https://github.com/apple/swift-evolution/blob/main/proposals/0409-access-level-on-imports.md) in a future Swift version. Not using `@\_implementationOnly` leads to errors when including the
prebuilt XCFramwork into projects, such as:

```sh
Sentry.swiftmodule/arm64-apple-ios.private.swiftinterface:10:8: error: no such module '_SentryPrivate'

import _SentryPrivate
```

Adding Objective-C classes to the \_SentryPrivate module also exposes them to test classes written in
Swift. When making an Objective-C class public to SDK Swift code, we must remove it from test
bridging headers because this can lead to compiler errors. The SentryTests only find the
\_SentryPrivate module when adding setting `HEADER_SEARCH_PATHS = $(SRCROOT)/Sources/Sentry/include/**`
which we must not set for SwiftUI, because this uses its own implementation of SentryInternal.h.
Setting the `HEADER_SEARCH_PATHS` for SwiftUI breaks the build.

See also [decision to remove SentryPrivate](./DECISIONS.md#removing-sentryprivate).

Useful resources:

- [Module Map Syntax](https://clang.llvm.org/docs/Modules.html#module-map-file)
- Sample GH Repo for [mixed Swift ObjC Framework](https://github.com/danieleggert/mixed-swift-objc-framework)
- [Swift Forum Discussion](https://forums.swift.org/t/mixing-swift-and-objective-c-in-a-framework-and-private-headers/27787/6)
- [Apple Docs: Importing Objective-C into Swift](https://developer.apple.com/documentation/swift/importing-objective-c-into-swift#Import-Code-Within-a-Framework-Target)

## Public Protocols

pod lib lint fails with the warning duplicate protocol definition when including a public header for
a protocol in a private ObjC class header, when adding that header to `SentryPrivate.h` to expose it
to internal SDK Swift code, as `SentrySDKInfo.h`. To solve this problem we have to use the
`SentryInternalSerializable` for internal classes implementing serializable.

## Compatibility Notes

- **visionOS**: Requires `SWIFT_OBJC_INTEROP_MODE=objcxx` for static framework
- **C Functions**: Cannot call C functions directly from Swift with visionOS settings

## Converting to Swift

Converting internal ObjC classes to Swift needs to be done following a partial order. The scripts in `SwiftConversion` generate this ordering and can be used to guide ObjC to Swift conversions.
