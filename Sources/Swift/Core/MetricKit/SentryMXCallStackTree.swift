@_implementationOnly import _SentryPrivate
import Foundation

#if os(iOS) || os(macOS)
/**
 * JSON specification of MXCallStackTree can be found here https://developer.apple.com/documentation/metrickit/mxcallstacktree/3552293-jsonrepresentation
 */
@objcMembers
@_spi(Private) public class SentryMXCallStackTree: NSObject, Codable {
    
    let callStacks: [SentryMXCallStack]
    public let callStackPerThread: Bool
    
    static func from(data: Data) throws -> SentryMXCallStackTree {
        return try JSONDecoder().decode(SentryMXCallStackTree.self, from: data)
    }
    
    func toDebugMeta() -> [DebugMeta] {
        callStacks.flatMap { frame in
            frame.toDebugMeta()
        }.unique { $0.debugID }
    }
    
    public func prepare(event: Event, inAppLogic: SentryInAppLogic, handled: Bool) {
        let debugMeta = toDebugMeta()
        let threads = sentryMXBacktrace(inAppLogic: inAppLogic, handled: handled)
        let crashedThread = threads.first { $0.crashed?.boolValue == true }
        event.debugMeta = debugMeta
        event.threads = threads
        
        if let crashedThread, let exception = event.exceptions?[0] {
            exception.stacktrace = crashedThread.stacktrace
            exception.threadId = crashedThread.threadId
        }
    }
    
    // A MetricKit CallStackTree is a flamegraph, but many Sentry APIs only support
    // a thread backtrace. A flamegraph is just a collection of many thread backtraces
    // generated by taking multiple samples. For example a hang from metric kit will
    // be a group of samples of the main thread while it is hanging. To make MetricKit
    // data compatible with Sentry data this function find the most commonly sampled stack.
    // Some metric kit events contain multiple threads (like a crash report) and others
    // contain all threads in one flamegraph. That happens when "callStackPerThread"
    // is false. In these cases we can't really make a "thread" because
    // it represents data that is sampled across many threads and aggregated, we do not
    // know which samples came from which thread. Instead we create just one fake thread
    // that just contains the most common callstack.
    func sentryMXBacktrace(inAppLogic: SentryInAppLogic, handled: Bool) -> [SentryThread] {
        callStacks.map { callStack in
            let thread = SentryThread(threadId: 0)
            let frames = callStack.toFrames()
            frames.forEach { $0.inApp = NSNumber(value: inAppLogic.is(inApp: $0.package)) }
            thread.stacktrace = SentryStacktrace(frames: frames, registers: [:])
            thread.crashed = NSNumber(value: (callStack.threadAttributed ?? false) && !handled)
            return thread
        }
    }
}

struct SentryMXCallStack: Codable {
    let threadAttributed: Bool?
    let callStackRootFrames: [SentryMXFrame]

    func toFrames() -> [Frame] {
        // The root node of a flamegraph is the first frame in a stacktrace (usually main)
        callStackRootFrames.mostSampled()?.toFrames().reversed() ?? []
    }
    
    func toDebugMeta() -> [DebugMeta] {
        callStackRootFrames.flatMap { frame in
            frame.toDebugMeta()
        }
    }
}

struct SentryMXFrame: Codable {
    let binaryUUID: UUID
    let offsetIntoBinaryTextSegment: Int
    let binaryName: String?
    let address: UInt64
    let subFrames: [SentryMXFrame]?
    let sampleCount: Int?
    
    func toSentryFrame() -> Frame {
        let frame = Frame()
        frame.package = binaryName
        frame.instructionAddress = sentry_formatHexAddressUInt64Swift(address)
        frame.imageAddress = sentry_formatHexAddressUInt64Swift(address - UInt64(offsetIntoBinaryTextSegment))
        return frame
    }

    func toFrames() -> [Frame] {
        return [toSentryFrame()] + (subFrames?.mostSampled()?.toFrames() ?? [])
    }
    
    func toDebugMeta() -> [DebugMeta] {
        let result = DebugMeta()
        result.type = SentryDebugImageType
        result.debugID = binaryUUID.uuidString
        result.codeFile = binaryName
        result.imageAddress = sentry_formatHexAddressUInt64Swift(address - UInt64(offsetIntoBinaryTextSegment))
        return [result] + (subFrames?.flatMap { $0.toDebugMeta() } ?? [])
    }
}

extension Sequence {
    func unique<T: Hashable>(by key: (Element) -> T) -> [Element] {
        var seen = Set<T>()
        var result: [Element] = []
        for element in self {
            let k = key(element)
            if !seen.contains(k) {
                seen.insert(k)
                result.append(element)
            }
        }

        return result
    }
}

extension Sequence where Element == SentryMXFrame {
    // A sentry frame is a list not a tree, find the most frequently sampled element at this level of the tree.
    func mostSampled() -> SentryMXFrame? {
        var mostSamples = -1
        var mostSampledFrame: SentryMXFrame?
        for frame in self {
            if frame.sampleCount ?? 0 > mostSamples {
                mostSamples = frame.sampleCount ?? 0
                mostSampledFrame = frame
            }
        }
        return mostSampledFrame
    }
}

#endif
