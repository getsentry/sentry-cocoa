@_implementationOnly import _SentryPrivate
import Foundation

#if os(iOS) || os(macOS)
/**
 * JSON specification of MXCallStackTree can be found here https://developer.apple.com/documentation/metrickit/mxcallstacktree/3552293-jsonrepresentation
 */
@objcMembers
@_spi(Private) public class SentryMXCallStackTree: NSObject, Decodable {
    
    let callStacks: [SentryMXCallStack]
    public let callStackPerThread: Bool
    
    static func from(data: Data) throws -> SentryMXCallStackTree {
        return try JSONDecoder().decode(SentryMXCallStackTree.self, from: data)
    }
    
    func toDebugMeta() -> [DebugMeta] {
        callStacks.flatMap { frame in
            frame.toDebugMeta()
        }.unique { $0.debugID }
    }
    
    public func prepare(event: Event, inAppLogic: SentryInAppLogic?, handled: Bool) {
        let debugMeta = toDebugMeta()
        let threads = sentryMXBacktrace(inAppLogic: inAppLogic, handled: handled)
        let crashedThread = threads.first { $0.crashed?.boolValue == true }
        event.debugMeta = debugMeta
        event.threads = threads
        
        if let crashedThread, let exception = event.exceptions?[0] {
            exception.stacktrace = crashedThread.stacktrace
            exception.threadId = crashedThread.threadId
        }
    }
    
    // A MetricKit CallStackTree is a flamegraph, but many Sentry APIs only support
    // a thread backtrace. A flamegraph is just a collection of many thread backtraces
    // generated by taking multiple samples. For example a hang from metric kit will
    // be a group of samples of the main thread while it is hanging. To make MetricKit
    // data compatible with Sentry data this function finds the most commonly sampled stack.
    // Some metric kit events contain multiple threads (like a crash report) and others
    // contain all threads in one flamegraph. That happens when "callStackPerThread"
    // is false. In these cases we can't really make a "thread" because
    // it represents data that is sampled across many threads and aggregated, we do not
    // know which samples came from which thread. Instead we create just one fake thread
    // that just contains the most common callstack.
    func sentryMXBacktrace(inAppLogic: SentryInAppLogic?, handled: Bool) -> [SentryThread] {
        callStacks.map { callStack in
            let thread = SentryThread(threadId: 0)
            let samples = callStack.callStackRootFrames.flatMap { $0.toSamples() }
            // Group by stacktrace in case there are multiple samples with the same trace
            var samplesToCount = [[Sample.Frame]: Int]()
            for sample in samples {
                let count = samplesToCount[sample.frames] ?? 0
                samplesToCount[sample.frames] = sample.count + count
            }
            let frames = samplesToCount.mostSampled()?.map { $0.toSentryFrame() } ?? []
            frames.forEach { $0.inApp = NSNumber(value: inAppLogic?.is(inApp: $0.package) ?? false) }
            thread.stacktrace = SentryStacktrace(frames: frames, registers: [:])
            thread.crashed = NSNumber(value: (callStack.threadAttributed ?? false) && !handled)
            return thread
        }
    }
}

// A Sample is the standard data format for a flamegraph taken from https://github.com/brendangregg/FlameGraph
// It is less compact than Apple's MetricKit format, but contains the same data and is easier to work with
struct Sample {
    let count: Int
    let frames: [Frame]
    
    struct Frame: Hashable {
        let binaryUUID: UUID
        let offsetIntoBinaryTextSegment: Int
        let binaryName: String?
        let address: UInt64
        
        func toSentryFrame() -> Sentry.Frame {
            let frame = Sentry.Frame()
            frame.package = binaryName
            frame.instructionAddress = sentry_formatHexAddressUInt64Swift(address)
            frame.imageAddress = sentry_formatHexAddressUInt64Swift(address - UInt64(offsetIntoBinaryTextSegment))
            return frame
        }
    }
}

struct SentryMXCallStack: Decodable {
    let threadAttributed: Bool?
    let callStackRootFrames: [SentryMXFrame]
    
    func toDebugMeta() -> [DebugMeta] {
        callStackRootFrames.flatMap { frame in
            frame.toDebugMeta()
        }
    }
}

struct SentryMXFrame: Decodable {
    let binaryUUID: UUID
    let offsetIntoBinaryTextSegment: Int
    let binaryName: String?
    let address: UInt64
    let subFrames: [SentryMXFrame]?
    let sampleCount: Int?
    
    func toDebugMeta() -> [DebugMeta] {
        let result = DebugMeta()
        result.type = SentryDebugImageType
        result.debugID = binaryUUID.uuidString
        result.codeFile = binaryName
        result.imageAddress = sentry_formatHexAddressUInt64Swift(address - UInt64(offsetIntoBinaryTextSegment))
        return [result] + (subFrames?.flatMap { $0.toDebugMeta() } ?? [])
    }
    
    func toSamples() -> [Sample] {
        let selfFrame = Sample.Frame(binaryUUID: binaryUUID, offsetIntoBinaryTextSegment: offsetIntoBinaryTextSegment, binaryName: binaryName, address: address)
        let subframes = subFrames ?? []

        let childCount = subframes.map { $0.sampleCount ?? 0 }.reduce(0, +)
        let selfCount = (sampleCount ?? 0) - childCount
        var result = subframes.flatMap { $0.toSamples() }.map { Sample(count: $0.count, frames: [selfFrame] + $0.frames) }
        if selfCount > 0 {
            result.append(Sample(count: selfCount, frames: [selfFrame]))
        }
        return result
    }
}

extension Sequence {
    func unique<T: Hashable>(by key: (Element) -> T) -> [Element] {
        var seen = Set<T>()
        var result: [Element] = []
        for element in self {
            let k = key(element)
            if !seen.contains(k) {
                seen.insert(k)
                result.append(element)
            }
        }

        return result
    }
}

extension Dictionary where Value == Int {
    func mostSampled() -> Key? {
        var mostSamples = -1
        var mostSampledKey: Key?
        for (key, value) in self {
            if value > mostSamples {
                mostSamples = value
                mostSampledKey = key
            }
        }
        return mostSampledKey
    }
}

#endif
