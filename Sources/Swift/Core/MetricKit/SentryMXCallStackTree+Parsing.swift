#if os(iOS) || os(macOS) || os(visionOS)

@_implementationOnly import _SentryPrivate

extension SentryMXCallStackTree {
    func toDebugMeta() -> [DebugMeta] {
        callStacks.flatMap { frame in
            frame.toDebugMeta()
        }.unique { $0.debugID }
    }
    
    func prepare(event: Event, inAppLogic: SentryInAppLogic?, handled: Bool) {
        let debugMeta = toDebugMeta()
        let threads = sentryMXBacktrace(inAppLogic: inAppLogic, handled: handled)
        // First look for the crashing thread, but for events that were not a crash (like a hang) take the first thread
        // since those events only report one thread
        let exceptionThread = threads.first { $0.crashed?.boolValue == true } ?? threads.first
        event.debugMeta = debugMeta
        event.threads = threads
        
        if let exceptionThread, let exception = event.exceptions?[0] {
            exception.stacktrace = exceptionThread.stacktrace
            exception.threadId = exceptionThread.threadId
        }
    }
    
    // A MetricKit CallStackTree is a flamegraph, but many Sentry APIs only support
    // a thread backtrace. A flamegraph is just a collection of many thread backtraces
    // generated by taking multiple samples. For example a hang from metric kit will
    // be a group of samples of the main thread while it is hanging. To make MetricKit
    // data compatible with Sentry data this function finds the most commonly sampled stack.
    // Some metric kit events contain multiple threads (like a crash report) and others
    // contain all threads in one flamegraph. That happens when "callStackPerThread"
    // is false. In these cases we can't really make a "thread" because
    // it represents data that is sampled across many threads and aggregated, we do not
    // know which samples came from which thread. Instead we create just one fake thread
    // that just contains the most common callstack.
    //
    // We hope to add flamegraph support at some point and that is tracked here: https://github.com/getsentry/sentry-cocoa/issues/7062
    func sentryMXBacktrace(inAppLogic: SentryInAppLogic?, handled: Bool) -> [SentryThread] {
        callStacks.enumerated().map { index, callStack in
            let thread = SentryThread(threadId: NSNumber(value: index))
            let samples = callStack.callStackRootFrames.flatMap { $0.toSamples() }
            // Group by stacktrace in case there are multiple samples with the same trace
            var samplesToCount = [[MXSample.MXFrame]: Int]()
            for sample in samples {
                let count = samplesToCount[sample.frames] ?? 0
                samplesToCount[sample.frames] = sample.count + count
            }
            let frames = samplesToCount.mostSampled()?.map { $0.toSentryFrame() } ?? []
            frames.forEach { $0.inApp = NSNumber(value: inAppLogic?.is(inApp: $0.package) ?? false) }
            thread.stacktrace = SentryStacktrace(frames: frames, registers: [:])
            thread.crashed = NSNumber(value: (callStack.threadAttributed ?? false) && !handled)
            return thread
        }
    }
}

extension SentryMXCallStack {
    func toDebugMeta() -> [DebugMeta] {
        callStackRootFrames.flatMap { frame in
            frame.toDebugMeta()
        }
    }
}

extension SentryMXFrame {
    func toDebugMeta() -> [DebugMeta] {
        let result = DebugMeta()
        result.type = "macho"
        result.debugID = binaryUUID.uuidString
        result.codeFile = binaryName
        if offsetIntoBinaryTextSegment >= 0 && offsetIntoBinaryTextSegment < address {
            result.imageAddress = sentry_formatHexAddressUInt64Swift(address - UInt64(offsetIntoBinaryTextSegment))
        }
        return [result] + (subFrames?.flatMap { $0.toDebugMeta() } ?? [])
    }
    
    func toSamples() -> [MXSample] {
        let selfFrame = MXSample.MXFrame(binaryUUID: binaryUUID, offsetIntoBinaryTextSegment: offsetIntoBinaryTextSegment, binaryName: binaryName, address: address)
        let subframes = subFrames ?? []

        let childCount = subframes.map { $0.sampleCount ?? 0 }.reduce(0, +)
        let selfCount = (sampleCount ?? 0) - childCount
        var result = subframes.flatMap { $0.toSamples() }.map { MXSample(count: $0.count, frames: [selfFrame] + $0.frames) }
        if selfCount > 0 {
            result.append(MXSample(count: selfCount, frames: [selfFrame]))
        }
        return result
    }
}

private extension MXSample.MXFrame {
    func toSentryFrame() -> Frame {
        let frame = Frame()
        frame.package = binaryName
        frame.instructionAddress = sentry_formatHexAddressUInt64Swift(address)
        if offsetIntoBinaryTextSegment >= 0 && offsetIntoBinaryTextSegment < address {
            frame.imageAddress = sentry_formatHexAddressUInt64Swift(address - UInt64(offsetIntoBinaryTextSegment))
        }
        return frame
    }
}

private extension Sequence {
    func unique<T: Hashable>(by key: (Element) -> T) -> [Element] {
        var seen = Set<T>()
        return filter { seen.insert(key($0)).inserted }
    }
}

private extension Dictionary where Value == Int {
    func mostSampled() -> Key? {
        var mostSamples = -1
        var mostSampledKey: Key?
        for (key, value) in self {
            if value > mostSamples {
                mostSamples = value
                mostSampledKey = key
            }
        }
        return mostSampledKey
    }
}

#endif
