#if os(iOS) || os(macOS)

@_implementationOnly import _SentryPrivate

extension SentryMXCallStackTree {
    func toDebugMeta() -> [DebugMeta] {
        callStacks.flatMap { frame in
            frame.toDebugMeta()
        }.unique { $0.debugID }
    }

    // A MetricKit CallStackTree is a flamegraph, but many Sentry APIs only support
    // a thread backtrace. A flamegraph is just a collection of many thread backtraces
    // generated by taking multiple samples. For example a hang from metric kit will
    // be a group of samples of the main thread while it is hanging. To make MetricKit
    // data compatible with Sentry data this function finds the most commonly sampled stack.
    // Some metric kit events contain multiple threads (like a crash report) and others
    // contain all threads in one flamegraph. That happens when "callStackPerThread"
    // is false. In these cases we can't really make a "thread" because
    // it represents data that is sampled across many threads and aggregated, we do not
    // know which samples came from which thread. Instead we create just one fake thread
    // that just contains the most common callstack.
    //
    // We hope to add flamegraph support at some point and that is tracked here: https://github.com/getsentry/sentry-cocoa/issues/7062
    func sentryMXBacktrace(inAppLogic: SentryInAppLogic?, handled: Bool) -> [SentryThread] {
        callStacks.enumerated().map { index, callStack in
            let thread = SentryThread(threadId: NSNumber(value: index))
            let samples = callStack.callStackRootFrames.flatMap { $0.toSamples() }
            // Group by stacktrace in case there are multiple samples with the same trace
            var samplesToCount = [[MXSample.MXFrame]: Int]()
            for sample in samples {
                let count = samplesToCount[sample.frames] ?? 0
                samplesToCount[sample.frames] = sample.count + count
            }
            let frames = samplesToCount.mostSampled()?.map { $0.toSentryFrame() } ?? []
            frames.forEach { $0.inApp = NSNumber(value: inAppLogic?.is(inApp: $0.package) ?? false) }
            thread.stacktrace = SentryStacktrace(frames: frames, registers: [:])
            thread.crashed = NSNumber(value: (callStack.threadAttributed ?? false) && !handled)
            return thread
        }
    }

    /// Flattens the call stack tree into a single thread with all frames.
    /// Each frame includes metadata in its `vars` field to allow reconstructing the original tree:
    /// - `parent_frame_index`: The index of the parent frame in the flat list (-1 for root frames)
    /// - `sample_count`: The number of samples at this frame
    ///
    /// This preserves all sample data from the flamegraph rather than just the most common stack.
    func flattenedBacktrace(inAppLogic: SentryInAppLogic?, handled: Bool) -> [SentryThread] {
        callStacks.enumerated().map { index, callStack in
            let thread = SentryThread(threadId: NSNumber(value: index))
            var frames: [Frame] = []

            // Traverse the tree and flatten all frames with parent references
            for rootFrame in callStack.callStackRootFrames {
                flattenFrame(rootFrame, parentIndex: -1, frames: &frames, inAppLogic: inAppLogic)
            }

            thread.stacktrace = SentryStacktrace(frames: frames, registers: [:])
            thread.crashed = NSNumber(value: (callStack.threadAttributed ?? false) && !handled)
            return thread
        }
    }

    private func flattenFrame(_ mxFrame: SentryMXFrame, parentIndex: Int, frames: inout [Frame], inAppLogic: SentryInAppLogic?) {
        let currentIndex = frames.count
        let frame = mxFrame.toSentryFrameWithTreeData(frameIndex: currentIndex, parentFrameIndex: parentIndex)
        frame.inApp = NSNumber(value: inAppLogic?.is(inApp: frame.package) ?? false)
        frames.append(frame)

        // Recursively process child frames
        for subFrame in mxFrame.subFrames ?? [] {
            flattenFrame(subFrame, parentIndex: currentIndex, frames: &frames, inAppLogic: inAppLogic)
        }
    }
}

extension SentryMXCallStack {
    func toDebugMeta() -> [DebugMeta] {
        callStackRootFrames.flatMap { frame in
            frame.toDebugMeta()
        }
    }
}

extension SentryMXFrame {
    func toDebugMeta() -> [DebugMeta] {
        let result = DebugMeta()
        result.type = "macho"
        result.debugID = binaryUUID.uuidString
        result.codeFile = binaryName
        if offsetIntoBinaryTextSegment >= 0 && offsetIntoBinaryTextSegment < address {
            result.imageAddress = sentry_formatHexAddressUInt64Swift(address - UInt64(offsetIntoBinaryTextSegment))
        }
        return [result] + (subFrames?.flatMap { $0.toDebugMeta() } ?? [])
    }

    func toSamples() -> [MXSample] {
        let selfFrame = MXSample.MXFrame(binaryUUID: binaryUUID, offsetIntoBinaryTextSegment: offsetIntoBinaryTextSegment, binaryName: binaryName, address: address)
        let subframes = subFrames ?? []

        let childCount = subframes.map { $0.sampleCount ?? 0 }.reduce(0, +)
        let selfCount = (sampleCount ?? 0) - childCount
        var result = subframes.flatMap { $0.toSamples() }.map { MXSample(count: $0.count, frames: [selfFrame] + $0.frames) }
        if selfCount > 0 {
            result.append(MXSample(count: selfCount, frames: [selfFrame]))
        }
        return result
    }

    /// Converts this frame to a SentryFrame with tree metadata in the `vars` field.
    /// The metadata allows reconstructing the original tree structure from a flat list.
    func toSentryFrameWithTreeData(frameIndex: Int, parentFrameIndex: Int) -> Frame {
        let frame = Frame()
        frame.package = binaryName
        frame.instructionAddress = sentry_formatHexAddressUInt64Swift(address)
        if offsetIntoBinaryTextSegment >= 0 && offsetIntoBinaryTextSegment < address {
            frame.imageAddress = sentry_formatHexAddressUInt64Swift(address - UInt64(offsetIntoBinaryTextSegment))
        }

        frame.parentIndex = parentFrameIndex as NSNumber
        frame.sampleCount = sampleCount as NSNumber?

        return frame
    }
}

private extension MXSample.MXFrame {
    func toSentryFrame() -> Frame {
        let frame = Frame()
        frame.package = binaryName
        frame.instructionAddress = sentry_formatHexAddressUInt64Swift(address)
        if offsetIntoBinaryTextSegment >= 0 && offsetIntoBinaryTextSegment < address {
            frame.imageAddress = sentry_formatHexAddressUInt64Swift(address - UInt64(offsetIntoBinaryTextSegment))
        }
        return frame
    }
}

private extension Sequence {
    func unique<T: Hashable>(by key: (Element) -> T) -> [Element] {
        var seen = Set<T>()
        return filter { seen.insert(key($0)).inserted }
    }
}

private extension Dictionary where Value == Int {
    func mostSampled() -> Key? {
        var mostSamples = -1
        var mostSampledKey: Key?
        for (key, value) in self {
            if value > mostSamples {
                mostSamples = value
                mostSampledKey = key
            }
        }
        return mostSampledKey
    }
}

#endif
