---
phase: 01-facade-design-implementation
plan: 02
type: execute
wave: 2
depends_on: [01-01]
files_modified:
  - Sources/Swift/Integrations/SentryCrash/SentryCrashIntegration.swift
autonomous: true

must_haves:
  truths:
    - "SentryCrashIntegration creates SentryCrashBridge instance during initialization"
    - "Facade is created before SentryCrash installation begins"
    - "Bridge receives services from dependencies parameter (notificationCenterWrapper, dateProvider, crashReporter)"
  artifacts:
    - path: "Sources/Swift/Integrations/SentryCrash/SentryCrashIntegration.swift"
      provides: "Integration that creates and provides facade before crash handler installation"
      contains: "let bridge = SentryCrashBridge("
  key_links:
    - from: "Sources/Swift/Integrations/SentryCrash/SentryCrashIntegration.swift"
      to: "SentryCrashBridge initializer"
      via: "instantiation in init(with:dependencies:)"
      pattern: "SentryCrashBridge\\(notificationCenterWrapper:"
    - from: "SentryCrashBridge instance"
      to: "Dependencies parameter services"
      via: "passed from dependencies in SentryCrashIntegration.init"
      pattern: "dependencies\\.notificationCenterWrapper|dependencies\\.dateProvider|dependencies\\.crashReporter"
---

<objective>
Integrate SentryCrashBridge into the SDK initialization path by creating and configuring the facade instance in SentryCrashIntegration before crash handler installation begins.

Purpose: Complete the facade initialization flow so SentryCrash can consume SDK services through the bridge. This ensures the facade is ready before any crash monitoring starts.

Output: Updated SentryCrashIntegration.swift that instantiates SentryCrashBridge from dependency-injected services and stores it for future SentryCrash consumption (Phase 2-3 will connect SentryCrash to the bridge).
</objective>

<execution_context>
@/Users/itaybrenner/.claude/get-shit-done/workflows/execute-plan.md
@/Users/itaybrenner/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-facade-design-implementation/01-RESEARCH.md
@.planning/phases/01-facade-design-implementation/01-01-SUMMARY.md

Implementation files:
@Sources/Swift/Integrations/SentryCrash/SentryCrashIntegration.swift
@Sources/Swift/Integrations/SentryCrash/SentryCrashBridge.swift
</context>

<tasks>

<task type="auto">
  <name>Add bridge property and initialization to SentryCrashIntegration</name>
  <files>Sources/Swift/Integrations/SentryCrash/SentryCrashIntegration.swift</files>
  <action>
Update SentryCrashIntegration.swift to create and store the SentryCrashBridge instance:

1. **Add bridge property** to SentryCrashIntegration class (around line 34, after other properties):
   - `private var bridge: SentryCrashBridge?`
   - Store as optional property since it's created during init (matches pattern of sessionHandler and scopeObserver)

2. **Create bridge instance** in `init(with:dependencies:)` method:
   - Add creation right after `super.init()` call (around line 49, before sessionHandler creation)
   - Instantiate: `let bridge = SentryCrashBridge(notificationCenterWrapper: dependencies.notificationCenterWrapper, dateProvider: dependencies.dateProvider, crashReporter: dependencies.crashReporter)`
   - Store: `self.bridge = bridge`
   - **Timing is critical**: Bridge must be created BEFORE `startCrashHandler()` is called (line 71-77) to ensure it's available when needed

3. **Verify dependencies protocol** provides required services:
   - Current protocol `CrashIntegrationProvider` (line 25) already includes `SentryCrashReporterProvider` which provides `crashReporter`
   - Check that `Dependencies` type also provides `notificationCenterWrapper` and `dateProvider`
   - If not on CrashIntegrationProvider, these services come from the base Dependencies type passed to init
   - Dependencies parameter is already used for crashReporter (line 47), so same instance has other services

4. **Follow existing patterns**:
   - Match initialization style from sessionHandler (line 51) and scopeObserver (line 52)
   - Use same optional property pattern
   - No changes to uninstall() method needed yet (will be used in Phase 2-3)

5. **Add inline comment** explaining timing:
   - "// Create facade before installing crash handler to ensure services are available"
   - Place above bridge creation code

**What NOT to change**:

- DO NOT modify Dependencies protocol types yet (Phase 2-3 will connect bridge to SentryCrash)
- DO NOT pass bridge to SentryCrash yet (Phase 2-3 handles that)
- DO NOT modify startCrashHandler method signature
- DO NOT add any container accesses (we're creating the facade FROM dependencies, not container)

**Note on dependencies parameter**: The `Dependencies` generic type (line 29) already provides access to all SDK services through dependency injection. We're extracting the three services needed for the bridge from this existing dependencies parameter, not accessing SentryDependencyContainer.
</action>
<verify>
Compilation check for all platforms:

```bash
cd /Users/itaybrenner/sentry/sentry-cocoa
make build-for-ios
make build-for-macos
```

Verify bridge instantiation:

```bash
grep -A 5 "let bridge = SentryCrashBridge" Sources/Swift/Integrations/SentryCrash/SentryCrashIntegration.swift
grep "private var bridge:" Sources/Swift/Integrations/SentryCrash/SentryCrashIntegration.swift
```

Expected: Bridge property declared, bridge instantiated before startCrashHandler call
</verify>
<done>

- SentryCrashIntegration.swift modified with bridge property
- Bridge instance created in init(with:dependencies:) before startCrashHandler
- Bridge receives three services from dependencies parameter (notificationCenterWrapper, dateProvider, crashReporter)
- Code compiles successfully on iOS and macOS
- Bridge creation happens after super.init() and before startCrashHandler()
- No SentryDependencyContainer accesses added
  </done>
  </task>

<task type="auto">
  <name>Run existing tests to verify no regressions</name>
  <files>N/A (verification only)</files>
  <action>
Run the SentryCrashIntegration test suite to ensure existing functionality is preserved:

1. **Start test server** (required per AGENTS.md):
   ```bash
   cd /Users/itaybrenner/sentry/sentry-cocoa
   make run-test-server
   ```

2. **Run SentryCrashIntegration tests**:
   ```bash
   make test TESTONLY="SentryCrashIntegrationTests"
   ```

3. **Verify no failures**: All existing tests should pass since we only added a property and instantiation without changing behavior

4. **Check for compilation on other platforms** (watchOS, tvOS, visionOS):
   ```bash
   make build-for-tvos
   make build-for-watchos
   ```

**Expected outcome**: All tests pass, all platforms compile. The bridge is created but not yet used by SentryCrash (usage comes in Phase 2-3).

**If tests fail**: Check that dependencies parameter actually provides the three required services. The current `Dependencies` generic type should already have them through the protocol composition.
</action>
<verify>
Test execution output shows all tests passing:

```bash
cd /Users/itaybrenner/sentry/sentry-cocoa
make test TESTONLY="SentryCrashIntegrationTests" 2>&1 | grep -E "Test Suite.*passed|failed"
```

Multi-platform compilation succeeds:

```bash
make build-for-ios && make build-for-macos && make build-for-tvos && echo "All platforms compile"
```

</verify>
  <done>
- SentryCrashIntegrationTests test suite passes without regressions
- iOS, macOS, and tvOS builds compile successfully
- No new test failures introduced
- Bridge creation does not break existing crash handler initialization flow
  </done>
</task>

</tasks>

<verification>
1. **Integration check**: SentryCrashIntegration creates bridge instance during init
2. **Timing check**: Bridge created after super.init() but before startCrashHandler call
3. **Service wiring**: Bridge receives notificationCenterWrapper, dateProvider, crashReporter from dependencies
4. **No regressions**: Existing SentryCrashIntegration tests pass
5. **Multi-platform**: Compiles on iOS, macOS, tvOS without errors
6. **No container coupling**: Code does not add any new SentryDependencyContainer accesses
</verification>

<success_criteria>

- [ ] SentryCrashIntegration has private bridge property
- [ ] Bridge instantiated in init(with:dependencies:) before crash handler starts
- [ ] Bridge receives three services from dependencies parameter
- [ ] SentryCrashIntegrationTests pass without regressions
- [ ] Code compiles on iOS, macOS, and tvOS
- [ ] No new SentryDependencyContainer references added
- [ ] Bridge property is stored for future use by SentryCrash (Phase 2-3)
      </success_criteria>

<output>
After completion, create `.planning/phases/01-facade-design-implementation/01-02-SUMMARY.md`
</output>
